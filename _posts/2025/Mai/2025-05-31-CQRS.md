---
layout: post
title: CQRS - Command Query Responsibility Segregation
date: 2025-05-31 14:58:36 +0200
categories: .NET C# Patterns
---
## Kossé ça CQRS ?!
**CQRS** est un pattern d'architecture qui sépare les opérations de lecture (**Query**) des opérations d'écriture (**Command**). Cette séparation permet d'optimiser les performances, la scalabilité et la sécurité des applications.

## 1. Concepts de base
- **Command** : Représente une action qui modifie l'état du système. Elle est généralement synchrone et peut être validée avant d'être exécutée.
- **Query** : Représente une demande de données sans modifier l'état du système. Elle est généralement asynchrone et peut être optimisée pour des lectures rapides.
- **Event** : Un événement qui est émis après qu'une commande a été traitée avec succès. Il peut être utilisé pour notifier d'autres parties du système des changements d'état.
- **Handler** : Un composant qui traite les commandes et les requêtes. Il peut être synchrone ou asynchrone.
- **MediatR** : Une bibliothèque populaire pour implémenter CQRS en .NET, qui facilite la communication entre les composants via des messages.

## 2. Ok mais concrètement, ça sert à quoi ?
**CQRS** est particulièrement utile dans les systèmes complexes où les opérations de lecture et d'écriture ont des exigences différentes. Au lieu d'avoir un modèle où y fait toutes les opérations et donc avoir un code complexe et difficile à maintenir, CQRS permet de séparer les préoccupations.

Chaque action sera gérée par un composant spécifique, ce qui rend le code plus clair et plus facile à tester. On doit chnager le code de l'annulation d'une commande ? 
=> On ne modifiera qu'une méthode spécifique, sans toucher aux autres parties du code.

## 3. Send Message vs Publish Event
Dans **CQRS**, il est courant d'utiliser des messages pour communiquer entre les différentes parties du système. Il existe deux approches principales :
- **Send Message** : Utilisé pour envoyer des commandes ou des requêtes à un service spécifique. C'est une approche synchrone où le destinataire doit traiter le message et renvoyer une réponse.
- **Publish Event** : Utilisé pour émettre des événements qui peuvent être traités par plusieurs abonnés. C'est une approche asynchrone où les abonnés peuvent réagir à l'événement sans attendre de réponse.

## 3. Avantages de CQRS
- **Scalabilité** : Les lectures et les écritures peuvent être optimisées indépendamment.
- **Performance** : Les modèles de données peuvent être adaptés pour les besoins spécifiques des opérations de lecture et d'écriture.
- **Sécurité** : Les permissions peuvent être gérées différemment pour les opérations de lecture et d'écriture.
- **Complexité** : Permet de gérer des systèmes complexes en séparant les préoccupations.
- **Flexibilité** : Facilite l'évolution des modèles de données et des opérations.

## 4. Exemple de mise en œuvre avec MediatR
MediatR est une bibliothèque qui facilite la mise en œuvre de CQRS en .NET. Elle permet de gérer les commandes, les requêtes et les événements de manière simple et efficace.

### 4.1 Installation de MediatR
Mediatr peut être installé via NuGet. Ouvrez votre terminal et exécutez la commande suivante :
```bash
dotnet add package MediatR
```

### 4.2 Configuration de MediatR
Dans `Program.cs` ou `Startup.cs`, vous devez configurer MediatR pour qu'il puisse trouver vos handlers et les enregistrer dans le conteneur d'injection de dépendances.

Dans le fichier `Program.cs`, ajoutez la configuration de MediatR :
```csharp
using MediatR;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

public class Program
{
    public static async Task Main(string[] args)
    {
        var host = Host.CreateDefaultBuilder(args)
            .ConfigureServices(services =>
            {
                services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Program).Assembly));
            })
            .Build();

        var mediator = host.Services.GetRequiredService<IMediator>();
    }
}
```
Dans le fichier `Startup.cs`, ajoutez la configuration de MediatR :
```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Startup).Assembly));
}
```
Ou bien pour plus de flexibilité dans les options de MediatR :
```csharp
services.AddMediatR(cfg =>
{
    cfg.RegisterServicesFromAssembly(typeof(Startup).Assembly);
    // Possibilité d’en ajouter d’autres :
    //cfg.RegisterServicesFromAssembly(typeof(OtherType).Assembly);
});
```
## 5. Exemple de code avec Send, IRequest et Handler
### 5.1 Création d'un message pour annuler une commande
Nous allons créer un exemple de message à envoyer pour annuler une commande.
Ce message contiendra les informations nécessaires pour annuler une commande, comme l'ID de la commande et le motif de l'annulation.

Nous n'allons plus faire des exemples pour des applications consoles, mais plutôt pour des applications web ou des API, car c'est plus courant dans les applications modernes.

Prenons l'exemple d'une API qui reçoit une requête pour annuler une commande. Nous allons utiliser MediatR pour envoyer un message qui sera traité par un handler spécifique.
```csharp
using MediatR;
using Microsoft.AspNetCore.Mvc;

public class AnnulerCommandeDto
{
    public Guid CommandeId { get; set; }
    public string MotifAnnulation { get; set; }
}

[Route("api/commandes")]
public class CommandesController: ControllerBase
{
    private readonly IMediator _mediator;

    public CommandesController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpPost("annuler")]
    public async Task<IActionResult> AnnulerCommande([FromBody] AnnulerCommandeDto dto)
    {
        var message = new AnnulerCommandeRequest(dto.CommandeId, motifAnnulation);
        // Envoi du message via MediatR
        await _mediator.Send(message);
        return Ok();
    }
}
```
Au départ, nous faisons une injection de dépendance de `IMediator` dans le contrôleur. Ensuite, nous créons un message `AnnulerCommandeRequest` qui contient les informations nécessaires pour annuler la commande. Enfin, nous utilisons `_mediator.Send(message)` pour envoyer le message.

Notons que la syntaxe moderne de C# permet d'utiliser les primary constructors pour simplifier l'injection de dépendances.
```csharp
using MediatR;
using Microsoft.AspNetCore.Mvc;

public class AnnulerCommandeDto
{
    public Guid CommandeId { get; set; }
    public string MotifAnnulation { get; set; }
}

[Route("api/commandes")]
public class CommandesController(IMediator mediator) : ControllerBase
{
    [HttpPost("annuler")]
    public async Task<IActionResult> AnnulerCommande([FromBody] AnnulerCommandeDto dto)
    {
        var message = new AnnulerCommandeRequest(dto.CommandeId, dto.MotifAnnulation);
        await mediator.Send(message);
        return Ok();
    }
}
```
C'est plus rapide et plus lisible, surtout pour les petites classes comme les contrôleurs et ça évite d'avoir à déclarer un champ privé pour `IMediator`.

C'est bien mais on va encore raccourcir le code en utilisant des `records`, qui sont des types immuables (les propriétés ne peuvent pas être modifiées après la création de l'objet).

```csharp
using MediatR;
using Microsoft.AspNetCore.Mvc;

public record AnnulerCommandeDto(Guid CommandeId, string MotifAnnulation);

[Route("api/commandes")]
public class CommandesController(IMediator mediator) : ControllerBase
{
    [HttpPost("annuler")]
    public async Task<IActionResult> AnnulerCommande([FromBody] AnnulerCommandeDto dto)
    {
        var message = new AnnulerCommandeRequest(dto.CommandeId, dto.MotifAnnulation);
        var result = await mediator.Send(message);
        return result.IsSuccess ? Ok() : BadRequest(result.Errors);
    }
}
```
Voilà, nous avons un contrôleur qui reçoit une requête pour annuler une commande et qui envoie un message via MediatR. Le code est plus concis et plus lisible grâce à l'utilisation des records et des primary constructors.

Pour l'exemple, j'ai mis le record dans le fichier du contrôleur, il n'est pas à mettre dans le contrôleur mais dans un fichier séparé, par exemple `AnnulerCommandeDto.cs`.

## 6. Réception du message et traitement avec MediatR
Notre contrôleur reçoit le message et l'envoie à MediatR. Maintenant, nous allons créer deux choses :
1. Un message qui représente l'action d'annuler une commande.
2. Un handler qui traitera ce message et effectuera l'annulation de la commande.

Comment allons-nous faire cela ? Nous allons utiliser `IRequest` pour créer un message et `IRequestHandler` pour créer un handler qui traitera ce message.


### 6.1 IRequest, IActionResult, et IRequestHandler
Ouille ouille en voilà encore des concepts à comprendre ! Ne vous inquiétez pas, nous allons les aborder un par un.
#### 6.1.1 IRequest
Le message envoyé par la méthode Send de MediatR est un objet qui implémente l'interface ÌRequest<TResponse>. Cette interface est utilisée pour représenter une requête qui attend une réponse de type TResponse. TReponse est le type de la réponse attendue après le traitement de la requête.

Pour cela, nous allons créer une classe qui implémente `IRequest` de MediatR, ce qui permet à MediatR de traiter ce message comme une commande et non un événement.

```csharp
public class AnnulerCommandeMessage : IRequest
{
    public Guid CommandeId { get; set; }
    public string MotifAnnulation { get; set; }

    public AnnulerCommandeMessage(Guid commandeId, string motifAnnulation)
    {
        CommandeId = commandeId;
        MotifAnnulation = motifAnnulation;
    }
}
```

#### 6.1.2 IRequestHandler
Ensuite, nous allons créer un handler qui traitera ce message. Ce handler implémentera `IRequestHandler` de MediatR.

```csharp
using MediatR;
using FluentResults;

public record AnnulerCommandeRequest(Guid CommandeId, string MotifAnnulation) : IRequest<Result>

public class AnnulerCommandeHandler: IRequestHandler<AnnulerCommandeRequest, Result>
{
    public async Task<Result> Handle(AnnulerCommandeRequest request, CancellationToken cancellationToken)
    {
        // Logique pour annuler la commande
        // Par exemple, appeler un service qui annule la commande dans la base de données
        // Si l'annulation réussit, retourner Result.Ok()
        // Sinon, retourner Result.Fail("Message d'erreur")

        return Result.Ok();
    }
}
```

#### 6.1.3 IActionResult

**TODO**.....

### 6.2 Diagramme de séquence
Voici un diagramme de séquence qui illustre le flux de la requête d'annulation de commande :

<img src="assets/img/Sequence_CQRS_Send.png" alt="Diagramme de séquence CQRS" />

## 7. Exemple de code avec Publish, INotification et INotificationHandler
Ici, le concept est un peu différent, on va avoir un message qui ne s'attend pas à une réponse, mais qui est publié pour notifier d'autres parties du système. On va utiliser `INotification` pour cela et la métode `Publish` de MediatR.

**TODO**.....
